# PHP语法初步

PHP是一种运行在服务器端的脚本语言，可以嵌入到HTML中

# PHP代码标记

ASP标记：<% php代码 %>
短标记：\<? php代码 ?>
脚本标记：\<script language=“php”> php代码 \</script>
标准标记（常用）：\<? php代码 ?>

# PHP注释

//：后面跟的所有内容都是注释
#：与//一样
/*
中间所有内容都是注释
\*/

# PHP语句分隔符

在PHP中，代码是以行为单位，系统需要通过判断行的结果，该结束通常都是一个符号：分号（;）

1. PHP中标记结束符?>自带语句结束符的效果，所以最后一行PHP代码可不加分号
2. PHP中其实很多代码的书写并不是嵌入到HTML中，而是单独存在，通常书写习惯中就不建议使用标记结束符?>

# PHP变量

```php
$var1 = 1; //定义变量并赋值
echo '<hr />' $var; //通过var1变量名来找到存储的内容，<hr />是换行
unset($var1); //删除变量
```

1. 变量名必须以“$”符号开始；
2. 名字由字母、下划线和数字构成，但是不能以数字开头；
3. 允许中文变量（不建议）。

## 预定义变量

提前定义的变量，系统定义的变量，存储许多需要用到的数据（预定义变量都是数组）

**$_GET**：获取所有表单以get方式提交的数据

**$_POST**：POST提交的数据都会保存在此

**$_REQUEST**：GET和POST提交的都会保存

$GLOBALS：PHP中所有的全局变量

**$_SERVER**：服务器信息

**$_SESSION**：session会话数据

**$_COOKIE**：cookie会话数据

$_ENV：环境信息

$_FILES：用户上传的文件信息

## 可变变量

如果一个变量保存的值刚好是另一个变量的名字，那么可以直接通过访问一个变量得到另一个变量的值

```php
<?php
	$a = 'b';
	$b = 'bb';
	echo $a; //输出b
	echo $$a; //输出bb
?>
```

## 变量传值

将一个变量赋值给另外一个变量

值传递：

```php
<?php
    $a = 1;
	$b = $a; //值传递
	$b = 2;
	echo $a, $b; //1,2
```

```php
<?php
    $a = 1;
	$b = &$a; //引用传递
	$b = 2;
	echo $a, $b; //2,2
```

# PHP常量

常量和变量一样，都是用来保存数据的

## 常量基本概念

const/constant，是一种在程序运行中，**不可改变的值**（与变量的区别，在定义的时候必须赋值）

常量一旦被定义，通常数据不可改变

## 常量定义形式

1. define(‘常量名’，常量值);
2. 5.3之后才有的 const 常量名 = 值;

```php
define('PI',3.14);
const PII = 3;
```

* 常量不需要使用$，一旦使用系统就会认为是变量

* 常量的名字通常是以大写字母为主（与变量以示区别）

* 常量的命名规则比变量松散，可以使用一些特殊字符，该方式只能以define定义

  ```php
  define('-_-','smile'); //正确
  const -_- = 'smile'; //错误
  echo -_-; //错误，因为其是特殊符号
  echo constant('-_-'); //正确
  ```

* define和const定义的常量是有区别的，在于访问权限的区别
* 常量不可删除

## 系统常量

系统帮助用户定义的常量，用户可以直接使用

PHP_VERSION：PHP版本号

PHP_INT_SIZE：整形大小

PHP_INT_MAX：整形所能表示的最大值（PHP整形是允许出现负数的）

```php
echo '<hr />' ,PHP_VERSION,'<br/>' PHP_INT_SIZE,'<br/>',PHP_INT_MAX;
//5.4.8
//4
//2147483647
```

在PHP中还有一些特殊的常量，他们由双下划线开始 + 常量名 + 双下划线结束，这种常量称之为系统魔术常量：魔术常量的值通常会跟着环境变化，但是用户改变不了

\__DIR__：当前被执行的脚本所在电脑的绝对路径

\__FILE__：当前被执行的脚本所在电脑的绝对路径（带自己文件的名字）

\__LINE__：当前所属的行数

\__NAMESPACE__：当前所属的命名空间

\__CLASS__：当前所属的类

\__METHOD__：当前所属的方法

# PHP数据类型

在PHP中值的是存储的数据本身的类型，而不是变量的类型，PHP是一种弱类型语言，变量本身没有数据类型

## 简单数据类型

* 整形：int/integer，系统分配4个字节存储，表示整数类型
  * $a = 120; //十进制
  * $a = 0b110; //二进制
  * $a = 0120; //八进制
  * $a = 0x120; //十六进制
  * Decbin()：十进制转二进制
  * Decoct()：十进制转八进制
  * Dechex()：十进制转十六进制
  * Bindec()：二进制转十进制
  
* 浮点型：float/double，系统分配8个字节存储，表示小数或者整型存不下的整数

  ```php
  $f1 = 1.23;
  $f2 = 1.23e10;
  $f3 = PHP_INT_MAX + 1; //整型超过自身存储大小之后会用浮点型存储
  var_dump($f1,$f2,$f3); //float(1.23) float(12300000000) float(2147483648)
  ```

  

* 字符串型：string，系统根据实际长度分配，表示字符串（引号）
* 布尔类型：bool/boolean，表示布尔类型，只有两个值：true和false

## 复合数据类型

* 对象类型：object，存放对象（面向对象）
* 数组类型：array，存储多个数据（一次性）

## 特殊数据类型

* 资源类型：resource，存放资源数据（PHP外部数据，如数据库、文件）
* 空类型：NULL，只有一个值就是NULL（不能运算）

## 数据类型转换

1. 自动转换：系统根据需求资金判定，自己转换（用的比较多，效率偏低）
2. 强制转换（手动）：人为根据需要的目标类型转换
   * 在变量前加一个括号，里面写上要转换的类型

字符串转数值的说明

* 布尔true为1，false为0
* 字符串转数值
  * 以字母开头的字符串，永远为0
  * 以数字开头的字符串，取到碰到字符串为止（不会同时包含两个小数点）

```php
$a = abc1.1.1;
$b = 1.1.1abc;
echo $a + $b; // 0 + 1.1 = 1.1
echo '<br/>',(float)$a,(float)$b; // 0 1.1
```

## 类型判断

通过类型判断函数来判断变量类型，最终返回这个变量所保存数据的数据类型：是一组以is\_开头后面跟类型名字的函数：is\_XXX(变量名)
Bool类型不可以使用echo来查看，可以使用var_dump结构查看

```php
$a = abc1.1.1;
$b = 1.1.1abc;
echo $a + $b; 
echo '<br/>',(float)$a,(float)$b;
echo '<hr/>';
var_dump(is_int($a)); //false
var_dump(is_string($a)); //true
```

还有一组函数可以用来获取以及设定数据（变量）的类型

Gettype(变量名)：获取类型，得到的是该类型对应的字符串

Settype(变量名，类型)：设定数据类型，与强制转换不同

* 强制转换(类型)变量名，是对数据值复制的内容进行处理（不会处理实际存储的内容）
* settype会直接改变数据本身

```php
$a = abc1.1.1;
$b = 1.1.1abc;
echo $a + $b; 
echo '<br/>',(float)$a,(float)$b;
echo '<hr/>';
var_dump(is_int($a)); //bool(false)
var_dump(is_string($a)); //bool(true)
echo '<hr/>';
echo gettype($a), '<br/>'; //string
var_dump(settype($b,'int')); //bool(true)
echo gettype($b),$b; //integer 1
```

# PHP运算符

## 比较运算符

* \>左边大于右边，返回结果true
* \>=左边大于等于右边
* ==左边的值与右边的值相等（大小）
* ===全等于，左边与右边相同，大小和类型都要相同
* !==不全等于，只有大小或者类型不同

```php
$a = '123';
$b = 123;
var_dump($a == $b); //bool(true)
var_dump($a === $b); //bool(false)
```

## 逻辑运算符

* && 逻辑与
* || 逻辑或
* ! 逻辑非

## 连接运算符

* . ：将两个字符串连接到一起
* .= ：复合运算，将左边的内容和右边的内容连接起来，然后重新赋值给左边变量

```php
$a = 'hello';
$b = 123;
echo $a . $b; //hello 123
$a .= $b;
echo $a; //hello 123
```

## 错误抑制符

在PHP中有一些错误可以提前预知，但是这些错误可能无法避免，但是又比希望报错给用户看，可以用错误抑制符来处理

* @：在可能出错的表达式前面运用@符号即可

```php
$a = 10;
$b = 0;
$a % $b; //报错
@($a % $b); //不会报错
```

错误抑制符通常在生产环境（上线）会用到，在开发的时候不会用：系统本身最好没有任何错误

## 三目运算符

表达式1 ? 表达式2 : 表达式3;

如果表达式1成立，那么执行表达式2，否则执行表达式3

## 位运算符

* &：按位与，两个位都为1，结果为1，否则为0
* |：按位或，两个有一个为1，结果为1
* ~：按位非，一个位如果为1，则变为0，否则反之
* ^：按位异或，两个相同则为0，不同则为1
* <<：按位左移，整个数向左移动一位，右边补0
* \>>：按位右移，左边补符号位对应内容（正数补0，负数补1）

```php
$a = 5; //  00000101
$b = -5;//  11111011
        //& 00000001 最终结果
var_dump($a & $b);
var_dump(~$b); // -5    11111011 补码
			  // 取反	 00000100
			  // 原码  00000100
```

* 系统进行任何位运算的时候都是使用的补码
* 运算结束之后都必须转换为原码才是最终要显示的数据

# PHP选择和循环

if，switch，for，while，do-while都和c语言一样

# PHP流程控制替代语法

```php+HTML
<table border=1>
    <?php for($i = 1;$i < 10;$i++)}?>
    <tr>
        <?php for ($j = 1;$j <= $i;$j++)}?>
        <td>
            <?php echo $i . ' * ' . $j . ' = ' . $i * $j;?>
        </td>
        <?php }?>
    </tr>
    <?php }?>
</table>
```

HTML和PHP混合使用，php语法的地方使用\<?php?>包括起来，上述代码可以替换为下面的代码，前面的 { 替换为 : ，后面的 } 替换为 endfor

```php+HTML
<table border=1>
    <?php for($i = 1;$i < 10;$i++):?>
    <tr>
        <?php for ($j = 1;$j <= $i;$j++):?>
        <td>
            <?php echo $i . ' * ' . $j . ' = ' . $i * $j;?>
        </td>
        <?php endfor;?>
    </tr>
    <?php endfor;?>
</table>
```

PHP应该在HTML中只做数据输出，输出通常伴有条件判断和循环操作，因此PHP提供了对应分支结构和循环结构的替代语法：全部都是对应的一个模式：
左大括号 { 使用 : 替代
右大括号 } 使用 end + 对应的起始标记替代

* if：if():    endif;
* switch：switch():    endswitch;
* for： for():    endfor;
* while：while():      endwhile;
* foreach：foreach():     endforeach;

# PHP常用系统函数

## 有关输出的函数

* print()：类似于echo输出提供的内容，本质上是一种结构（不是函数），返回1，可以不需要使用括号
* print_r()：类似于var_dump，但是比var_dump简单，不会输出数据的类型，只会输出值（数）

```php
echo print('hello world'); //hello world
print 'hello world';       //1hello world 这个1是属于第一行的echo
$a = 'hello world';        //hello world
print_r($a);               //
```



## 有关时间的函数

* date()：按照指定格式对应的时间戳（从1970年格林威治开始计算的秒数），如果没有指定特定的时间戳，则解释为当前的时间戳
* time()：获取当前时间对应的时间戳
* microtime()：获取微秒级别的时间
* strtotime()：按照规定格式的字符串转换为时间戳

```php
echo date('Y 年 m 月 d 日 H:i:s'); //2023 年 12 月 16 日 10:35:12
echo time(),'<br/>'; //1702722932
echo microtime(),'<br/>'; //0.37360800 1702722949
echo strtotime(tomorrow 10 hours),'<br/>'; //1702807200
echo strtotime('10 hours') - time(),'<br/>'; //36000
```



## 有关数学的函数



# PHP文件包含

在一个PHP脚本中，去将另外一个文件（PHP）包含进来，去合作完成一件事情

## 作用

* 要么使用被包含文件中的内容，实现代码的共享（重用）：向上包含（索要）

  向上包含：在当前脚本要用某个代码之前包含别的文件

* 要么自己有东西可以给别的文件使用，实现代码的共享（重用）：向下包含（给予）

  向下包含：在自己有某个东西的时候，需要别的脚本来显示（自己代码写完之后包含其他文件）

* 最大的作用，分工协作，每个脚本做的事情不一样，因此可以使用协作方式，让多个脚本共同完成一件事情。

## 四种形式

1. include：包含文件
2. include_once：系统会自动判断文件包含过程中，是否己经包含过（一个文件最多被包含一次）
3. require：与include相同
4. require_once：与include_once相同

**向上包含（先包含文件，后使用文件中的内容）**

```php
//include1.php
<?php
	//被包含文件
    $a = 1;
	define('PI',3.14);
?>
```

```php
//include2.php
<?php
	//包含文件：使用数据
    include 'include1.php';//包含当前文件include2.php所在文件夹下的include1.php
	echo $a,PI;
?>
```

**向下包含（先准备内容，然后包含另外的文件，在另外的文件中，使用当前的内容）**

```php
//include3.php
<?php
	$a = 10;
	const PI = 3.14;
	include_once 'include4.php';
?>
```

```php
//include4.php
<table>
    <tr>
    	<td><?php echo $a;?></td>
        <td><?php echo PI;?></td>
    <tr>
</table>
```

## 文件加载原理

1. 在文件加载（include或者require）的时候，系统会自动的将被包含文件中的代码相当于嵌入到当前文件中

2. 加载位置：在哪加载，对应的文件的代码嵌入的位置就是对应的include位置

3. 在PHP中被包含的文件是单独进行编译的，这就意味着：

   PHP文件在编译的过程中如果出现了语法错误，那么会失败（不会执行）；但是如果被包含文件有错误的时候，系统会在执行到包含include这条语句的时候才会报错

## include和require的区别

**include和include_once的区别**

* include系统会碰到一次执行一次，如果对一个文件进行多次加载，那么系统会执行多次
* include_once系统碰到多次，也只会执行一次

**require和include的区别**

本质上都是包含文件，唯一的区别在于包含不到文件的时候，报错的形式不一样

include报错级别较轻，不会阻止后面的代码执行

require报错级别较重，会阻止后面的代码执行

# PHP文件加载路径

文件在加载的时候需要指定文件路径才能保证PHP正确的找到对应的文件

```php
<?php
include_once 'include1.php';
include_once './include1.php';
include_once '../htdocs/include1.php';
include_once 'D:/Apache/htdocs/include1.php';
?>
```

# PHP函数